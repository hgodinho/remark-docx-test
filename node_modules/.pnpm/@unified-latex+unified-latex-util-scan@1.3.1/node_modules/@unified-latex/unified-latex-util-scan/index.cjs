"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var unified_latex_util_scan_exports = {};
__export(unified_latex_util_scan_exports, {
  Trie: () => import_trie_prefix_tree.default,
  prefixMatch: () => prefixMatch,
  scan: () => scan
});
module.exports = __toCommonJS(unified_latex_util_scan_exports);

// libs/scan.ts
var import_unified_latex_util_match = require("@unified-latex/unified-latex-util-match");
var import_unified_latex_util_print_raw = require("@unified-latex/unified-latex-util-print-raw");
function scan(nodes, token, options) {
  const { startIndex, onlySkipWhitespaceAndComments, allowSubstringMatches } = options || {};
  if (typeof token === "string") {
    token = { type: "string", content: token };
  }
  for (let i = startIndex || 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (node.type === token.type) {
      switch (node.type) {
        case "comment":
        case "displaymath":
        case "inlinemath":
        case "root":
        case "parbreak":
        case "whitespace":
        case "verb":
        case "verbatim":
        case "group":
          return i;
        case "macro":
          if (node.content === token.content) {
            return i;
          }
          break;
        case "environment":
        case "mathenv":
          if ((0, import_unified_latex_util_print_raw.printRaw)(node.env) === (0, import_unified_latex_util_print_raw.printRaw)(token.env)) {
            return i;
          }
          break;
        case "string":
          if (node.content === token.content) {
            return i;
          }
          if (allowSubstringMatches && node.content.indexOf(token.content) >= 0) {
            return i;
          }
          break;
      }
    }
    if (onlySkipWhitespaceAndComments && !import_unified_latex_util_match.match.whitespace(node) && !import_unified_latex_util_match.match.comment(node)) {
      return null;
    }
  }
  return null;
}

// libs/prefix-match.ts
var import_trie_prefix_tree = __toESM(require("trie-prefix-tree"), 1);
var import_unified_latex_util_match2 = require("@unified-latex/unified-latex-util-match");
function prefixMatch(nodes, prefixes, options) {
  const {
    startIndex = 0,
    matchSubstrings = false,
    assumeOneCharStrings = false
  } = options || {};
  if (typeof prefixes === "string") {
    prefixes = [prefixes];
  }
  if (Array.isArray(prefixes)) {
    prefixes = (0, import_trie_prefix_tree.default)(prefixes);
  }
  const prefixTree = prefixes;
  const history = {
    lastPrefix: "",
    lastWord: "",
    index: startIndex,
    partialMatch: ""
  };
  function tryToMatchNextChar(char, index) {
    let ret = false;
    if (prefixTree.isPrefix(history.lastPrefix + char)) {
      history.lastPrefix += char;
      history.index = index;
      ret = true;
    }
    if (prefixTree.hasWord(history.lastPrefix)) {
      history.lastWord = history.lastPrefix;
    }
    return ret;
  }
  for (let i = 0; startIndex + i < nodes.length; i++) {
    const node = nodes[startIndex + i];
    if (!import_unified_latex_util_match2.match.string(node)) {
      break;
    }
    if (assumeOneCharStrings && node.content.length !== 1) {
      break;
    }
    if (matchSubstrings) {
      let fullMatch = true;
      history.partialMatch = "";
      for (let j = 0; j < node.content.length; j++) {
        const char = node.content[j];
        if (tryToMatchNextChar(char, startIndex + i)) {
          history.partialMatch += char;
        } else {
          fullMatch = false;
          break;
        }
      }
      if (fullMatch) {
        history.partialMatch = "";
      } else {
        break;
      }
    } else {
      if (!tryToMatchNextChar(node.content, startIndex + i)) {
        break;
      }
    }
  }
  return history.lastWord ? {
    match: history.lastWord,
    endNodeIndex: history.index,
    endNodePartialMatch: history.partialMatch ? history.partialMatch : null
  } : null;
}
//# sourceMappingURL=index.cjs.map
