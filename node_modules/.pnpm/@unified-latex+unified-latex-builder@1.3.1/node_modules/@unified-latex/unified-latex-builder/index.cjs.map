{
  "version": 3,
  "sources": ["../index.ts", "../libs/builders.ts"],
  "sourcesContent": ["export * from \"./libs/builders\";\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * Functions to help build a `unified-latex` Abstract Syntax Tree (AST)\n * with [hyperscript](https://github.com/dominictarr/hyperscript)-like syntax.\n *\n * ## When should I use this?\n *\n * If you want to programmatically create `Ast.Node` nodes.\n * \n */\n", "import type * as Ast from \"@unified-latex/unified-latex-types\";\n\ntype CoercibleNode = string | Ast.Node;\ntype CoercibleArgument = null | CoercibleNode | Ast.Argument;\ntype MacroSpecialOptions = {\n    escapeToken?: string;\n};\ntype ArgumentsSpecialOptions = {\n    braces?: string;\n    defaultOpenMark?: string;\n    defaultCloseMark?: string;\n};\ntype ArgumentSpecialOptions = {\n    braces?: string;\n    openMark?: string;\n    closeMark?: string;\n};\n\nfunction normalizeNode(node: CoercibleNode): Ast.Node {\n    if (typeof node === \"string\") {\n        return s(node);\n    }\n    return node;\n}\n\nfunction normalizeArgument(\n    arg: CoercibleArgument,\n    openMark = \"{\",\n    closeMark = \"}\"\n): Ast.Argument {\n    if (arg == null) {\n        return { type: \"argument\", content: [], openMark: \"\", closeMark: \"\" };\n    }\n    if (typeof arg === \"string\") {\n        return {\n            type: \"argument\",\n            openMark,\n            closeMark,\n            content: [s(arg)],\n        };\n    }\n    if (arg.type === \"argument\") {\n        return arg;\n    }\n    return { type: \"argument\", openMark, closeMark, content: [arg] };\n}\n\nfunction normalizeArgumentsList(\n    args?: CoercibleArgument | CoercibleArgument[],\n    openMark = \"{\",\n    closeMark = \"}\"\n): Ast.Argument[] {\n    if (args == null) {\n        return [];\n    }\n    if (Array.isArray(args)) {\n        return args.map((arg) => normalizeArgument(arg, openMark, closeMark));\n    }\n    return [normalizeArgument(args, openMark, closeMark)];\n}\n\ntype BracesPair = { openMark: string; closeMark: string };\nconst BRACES_MAP: Record<string, BracesPair> = {\n    \"*\": { openMark: \"\", closeMark: \"\" },\n    \"{\": { openMark: \"{\", closeMark: \"}\" },\n    \"[\": { openMark: \"[\", closeMark: \"]\" },\n    \"(\": { openMark: \"(\", closeMark: \")\" },\n    \"<\": { openMark: \"<\", closeMark: \">\" },\n};\nconst CLOSE_BRACES = new Set(\n    Object.values(BRACES_MAP)\n        .map((x) => x.closeMark)\n        .filter((x) => x)\n);\n\n/**\n * Turn a braces signature into an array of braces.\n */\nfunction bracesToOpenAndCloseMarks(braces: string): BracesPair[] {\n    const ret: BracesPair[] = [];\n\n    for (const char of braces.split(\"\")) {\n        if (CLOSE_BRACES.has(char)) {\n            continue;\n        }\n        const braces = BRACES_MAP[char];\n        if (braces == null) {\n            throw new Error(`Unknown open/close mark type \"${char}\"`);\n        }\n        braces;\n        ret.push(braces);\n    }\n\n    return ret;\n}\n\n/**\n * Create an Argument list. `special.braces` can optionally specify\n * the signature of the open/close marks that each argument uses. For example\n * ```\n * args([\"a\", \"b\"], { braces: \"[]{}\" });\n * ```\n * will result in arguments `[a]{b}`. Valid braces are `*`, `[`, `{`, `(`, and `<`.\n *\n * `null` may be passed as the value of an empty optional argument. If `null` is passed,\n * the `openBrace` and `closeBrace` of the argument will be set to empty strings and the\n * contents will be set to an empty array. For example,\n * ```\n * args([null, \"b\"], { braces: \"[]{}\" });\n * ```\n * will produce the same structure as if the the first \"optional argument\" were omitted in regular parsing.\n */\nexport function args(\n    args: CoercibleArgument | CoercibleArgument[],\n    special?: ArgumentsSpecialOptions\n): Ast.Argument[] {\n    if (!Array.isArray(args)) {\n        args = [args];\n    }\n    if (special?.braces) {\n        const braces = bracesToOpenAndCloseMarks(special.braces);\n        if (braces.length !== args.length) {\n            throw new Error(\n                `There is a difference between the number of supplied braces and the number of supplied arguments. ${args.length} supplied with braces signature ${special.braces}`\n            );\n        }\n        return args.map((arg, i) =>\n            normalizeArgument(arg, braces[i].openMark, braces[i].closeMark)\n        );\n    }\n\n    const openMark = special?.defaultOpenMark ?? \"{\";\n    const closeMark = special?.defaultCloseMark ?? \"}\";\n    return normalizeArgumentsList(args, openMark, closeMark);\n}\n\n/**\n * Create an Argument. `special.braces` can optionally specify\n * the signature of the open/close marks that each argument uses. For example\n * ```\n * arg(\"a\", { braces: \"[]\" });\n * ```\n * will result in arguments `[a]`. Valid braces are `*`, `[`, `{`, `<`, and `(`.\n *\n * `null` may be passed as the value of an empty optional argument. If `null` is passed,\n * the `openBrace` and `closeBrace` of the argument will be set to empty strings and the\n * contents will be set to an empty array. For example,\n * ```\n * args([null, \"b\"], { braces: \"[]{}\" });\n * ```\n * will produce the same structure as if the the first \"optional argument\" were omitted in regular parsing.\n */\nexport function arg(\n    args: CoercibleArgument | Ast.Node[],\n    special?: ArgumentSpecialOptions\n): Ast.Argument {\n    if (args == null) {\n        return { type: \"argument\", content: [], openMark: \"\", closeMark: \"\" };\n    }\n    if (typeof args === \"string\") {\n        args = s(args);\n    }\n    if (!Array.isArray(args) && args.type === \"argument\") {\n        return args;\n    }\n\n    let openMark = special?.openMark ?? \"{\";\n    let closeMark = special?.closeMark ?? \"}\";\n    if (special?.braces) {\n        const braces = bracesToOpenAndCloseMarks(special.braces);\n        if (braces[0]) {\n            openMark = braces[0].openMark;\n            closeMark = braces[0].closeMark;\n        }\n    }\n\n    if (!Array.isArray(args)) {\n        args = [args];\n    }\n\n    return { type: \"argument\", content: args, openMark, closeMark };\n}\n\n/**\n * Create a Macro with the given `name`. The macro\n * may be followed by any number of arguments.\n */\nexport function m(\n    name: string,\n    marcoArgs?: CoercibleArgument | CoercibleArgument[],\n    special?: MacroSpecialOptions\n): Ast.Macro {\n    const args = normalizeArgumentsList(marcoArgs);\n    const escapeToken = special?.escapeToken;\n    const ret: Ast.Macro = { type: \"macro\", content: name };\n\n    if (args.length > 0) {\n        ret.args = args;\n    }\n    if (escapeToken != null) {\n        ret.escapeToken = escapeToken;\n    }\n\n    return ret;\n}\n\n/**\n * Create a String node from `value`\n */\nexport function s(value: string | Ast.String): Ast.String {\n    if (typeof value === \"string\") {\n        return { type: \"string\", content: value };\n    }\n    return value;\n}\n\n/**\n * Create an Environment node.\n */\nexport function env(\n    name: string,\n    body: CoercibleNode | CoercibleNode[],\n    envArgs?: CoercibleArgument | CoercibleArgument[],\n    special?: unknown\n): Ast.Environment {\n    if (!Array.isArray(body)) {\n        body = [body];\n    }\n    const args = normalizeArgumentsList(envArgs, \"[\", \"]\");\n    const ret: Ast.Environment = {\n        type: \"environment\",\n        env: name,\n        content: body.map(normalizeNode),\n    };\n    if (args.length > 0) {\n        ret.args = args;\n    }\n\n    return ret;\n}\n\n/**\n * Whitespace node.\n */\nexport const SP: Ast.Whitespace = { type: \"whitespace\" };\n"],
  "mappings": "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",
  "names": ["arg", "args", "braces"]
}
