{
  "version": 3,
  "sources": ["../index.ts", "../libs/match.ts"],
  "sourcesContent": ["export * from \"./libs/match\";\n\n// NOTE: The docstring comment must be the last item in the index.ts file!\n/**\n * ## What is this?\n *\n * Functions to match different `Ast.Node` types in a `unified-latex` Abstract Syntax Tree (AST).\n *\n * ## When should I use this?\n *\n * If you need a type-guard to ensure a node is of a certain type; for example, during a call to `unified-latex-until-visit`.\n */\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport {\n    EnvInfo,\n    MacroInfo,\n    MacroInfoRecord,\n} from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros\n * and generates a hash for quick lookup.\n */\nfunction createMacroMatcher<S extends string>(\n    macros: Ast.Macro[] | S[] | Record<S, unknown>\n) {\n    // We first make sure we have a record type with keys being the macro's contents\n    const macrosHash: Record<string, unknown> = Array.isArray(macros)\n        ? macros.length > 0\n            ? typeof macros[0] === \"string\"\n                ? Object.fromEntries(\n                      macros.map((macro) => {\n                          if (typeof macro !== \"string\") {\n                              throw new Error(\"Wrong branch of map function\");\n                          }\n                          return [macro, {}] as [string, MacroInfo];\n                      })\n                  )\n                : Object.fromEntries(\n                      macros.map((macro) => {\n                          if (typeof macro === \"string\") {\n                              throw new Error(\"Wrong branch of map function\");\n                          }\n                          if (macro.escapeToken != null) {\n                              return [\n                                  macro.content,\n                                  { escapeToken: macro.escapeToken },\n                              ] as [string, MacroInfo];\n                          }\n                          return [macro.content, {}] as [string, MacroInfo];\n                      })\n                  )\n            : {}\n        : macros;\n\n    return function matchAgainstMacros(node: any | Ast.Macro) {\n        if (node == null || node.type !== \"macro\") {\n            return false;\n        }\n        // At this point we have a macro type\n        const spec = macrosHash[node.content];\n        if (!spec) {\n            return false;\n        }\n\n        if (typeof spec === \"object\" && \"escapeToken\" in spec) {\n            return (\n                (spec as MacroInfoRecord).escapeToken == null ||\n                (spec as MacroInfoRecord).escapeToken === node.escapeToken\n            );\n        }\n        return true;\n    } as Ast.TypeGuard<Ast.Macro & { content: S }>;\n}\n\n/**\n * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros\n * and generates a hash for quick lookup.\n */\nfunction createEnvironmentMatcher(macros: string[] | Record<string, unknown>) {\n    // We first make sure we have a record type with keys being the macro's contents\n    const environmentsHash = Array.isArray(macros)\n        ? Object.fromEntries(\n              macros.map((str) => {\n                  return [str, {}] as [string, EnvInfo];\n              })\n          )\n        : macros;\n\n    return function matchAgainstEnvironments(node: any | Ast.Environment) {\n        if (!match.anyEnvironment(node)) {\n            return false;\n        }\n        // At this point we have an environment type\n        const envName = printRaw(node.env);\n        const spec = environmentsHash[envName];\n        if (!spec) {\n            return false;\n        }\n\n        return true;\n    } as Ast.TypeGuard<Ast.Environment>;\n}\n\n/**\n * Functions to match different types of nodes.\n */\nexport const match = {\n    macro(node: any, macroName?: string): node is Ast.Macro {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"macro\" &&\n            (macroName == null || node.content === macroName)\n        );\n    },\n    anyMacro(node: any): node is Ast.Macro {\n        return match.macro(node);\n    },\n    environment(node: any, envName?: string): node is Ast.Environment {\n        if (node == null) {\n            return false;\n        }\n        return (\n            (node.type === \"environment\" || node.type === \"mathenv\") &&\n            (envName == null || printRaw(node.env) === envName)\n        );\n    },\n    anyEnvironment(node: any): node is Ast.Environment {\n        return match.environment(node);\n    },\n    comment(node: any): node is Ast.Comment {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"comment\";\n    },\n    parbreak(node: any): node is Ast.Parbreak {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"parbreak\";\n    },\n    whitespace(node: any): node is Ast.Whitespace {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"whitespace\";\n    },\n    /**\n     * Matches whitespace or a comment with leading whitespace.\n     */\n    whitespaceLike(\n        node: any\n    ): node is Ast.Whitespace | (Ast.Comment & { leadingWhitespace: true }) {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"whitespace\" ||\n            (node.type === \"whitespace\" && node.leadingWhitespace === true)\n        );\n    },\n    string(node: any, value?: string): node is Ast.String {\n        if (node == null) {\n            return false;\n        }\n        return (\n            node.type === \"string\" && (value == null || node.content === value)\n        );\n    },\n    anyString(node: any): node is Ast.String {\n        return match.string(node);\n    },\n    group(node: any): node is Ast.Group {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"group\";\n    },\n    argument(node: any): node is Ast.Argument {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"argument\";\n    },\n    blankArgument(node: any): boolean {\n        if (!match.argument(node)) {\n            return false;\n        }\n        return (\n            node.openMark === \"\" &&\n            node.closeMark === \"\" &&\n            node.content.length === 0\n        );\n    },\n    math(node: any): node is Ast.DisplayMath | Ast.InlineMath {\n        if (node == null) {\n            return false;\n        }\n        return node.type === \"displaymath\" || node.type === \"inlinemath\";\n    },\n    createMacroMatcher,\n    createEnvironmentMatcher,\n};\n\nexport const {\n    anyEnvironment,\n    anyMacro,\n    anyString,\n    argument,\n    blankArgument,\n    comment,\n    environment,\n    group,\n    macro,\n    math,\n    parbreak,\n    string,\n    whitespace,\n} = match;\n"],
  "mappings": "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",
  "names": ["macro"]
}
