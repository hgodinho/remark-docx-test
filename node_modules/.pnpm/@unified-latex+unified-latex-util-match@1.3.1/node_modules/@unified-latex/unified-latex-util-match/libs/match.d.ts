import * as Ast from "@unified-latex/unified-latex-types";
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
declare function createMacroMatcher<S extends string>(macros: Ast.Macro[] | S[] | Record<S, unknown>): Ast.TypeGuard<Ast.Macro & {
    content: S;
}>;
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
declare function createEnvironmentMatcher(macros: string[] | Record<string, unknown>): Ast.TypeGuard<Ast.Environment>;
/**
 * Functions to match different types of nodes.
 */
export declare const match: {
    macro(node: any, macroName?: string): node is Ast.Macro;
    anyMacro(node: any): node is Ast.Macro;
    environment(node: any, envName?: string): node is Ast.Environment;
    anyEnvironment(node: any): node is Ast.Environment;
    comment(node: any): node is Ast.Comment;
    parbreak(node: any): node is Ast.Parbreak;
    whitespace(node: any): node is Ast.Whitespace;
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node: any): node is Ast.Whitespace | (Ast.Comment & {
        leadingWhitespace: true;
    });
    string(node: any, value?: string): node is Ast.String;
    anyString(node: any): node is Ast.String;
    group(node: any): node is Ast.Group;
    argument(node: any): node is Ast.Argument;
    blankArgument(node: any): boolean;
    math(node: any): node is Ast.InlineMath | Ast.DisplayMath;
    createMacroMatcher: typeof createMacroMatcher;
    createEnvironmentMatcher: typeof createEnvironmentMatcher;
};
export declare const anyEnvironment: (node: any) => node is Ast.Environment, anyMacro: (node: any) => node is Ast.Macro, anyString: (node: any) => node is Ast.String, argument: (node: any) => node is Ast.Argument, blankArgument: (node: any) => boolean, comment: (node: any) => node is Ast.Comment, environment: (node: any, envName?: string) => node is Ast.Environment, group: (node: any) => node is Ast.Group, macro: (node: any, macroName?: string) => node is Ast.Macro, math: (node: any) => node is Ast.InlineMath | Ast.DisplayMath, parbreak: (node: any) => node is Ast.Parbreak, string: (node: any, value?: string) => node is Ast.String, whitespace: (node: any) => node is Ast.Whitespace;
export {};
//# sourceMappingURL=match.d.ts.map