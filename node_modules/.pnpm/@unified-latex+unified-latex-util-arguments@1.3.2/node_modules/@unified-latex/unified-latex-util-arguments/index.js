// libs/gobble-arguments.ts
import {
  parse as parseArgspec
} from "@unified-latex/unified-latex-util-argspec";
import { arg as arg2 } from "@unified-latex/unified-latex-builder";

// libs/gobble-single-argument.ts
import { match } from "@unified-latex/unified-latex-util-match";
import { scan } from "@unified-latex/unified-latex-util-scan";
import { arg } from "@unified-latex/unified-latex-builder";
function gobbleSingleArgument(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "string" || !argSpec.type) {
    throw new Error(
      `argSpec must be an already-parsed argument specification, not "${JSON.stringify(
        argSpec
      )}"`
    );
  }
  let argument = null;
  let currPos = startPos;
  const gobbleWhitespace = argSpec.noLeadingWhitespace ? () => {
  } : () => {
    while (currPos < nodes.length) {
      if (!match.whitespace(nodes[currPos])) {
        break;
      }
      currPos++;
    }
  };
  const openMark = argSpec.openBrace || "";
  const closeMark = argSpec.closeBrace || "";
  const acceptGroup = (argSpec.type === "mandatory" || argSpec.type === "optional") && openMark === "{" && closeMark === "}";
  function findBracePositions() {
    let openMarkPos = null;
    if (openMark) {
      openMarkPos = nodes.findIndex(
        (node, i) => i >= currPos && match.string(node, openMark)
      );
      if (openMarkPos < currPos) {
        openMarkPos = null;
      }
    }
    let closeMarkPos = null;
    if (openMarkPos != null) {
      closeMarkPos = nodes.findIndex(
        (node, i) => i >= openMarkPos + 1 && match.string(node, closeMark)
      );
      if (closeMarkPos < openMarkPos + 1) {
        closeMarkPos = null;
      }
    }
    return [openMarkPos, closeMarkPos];
  }
  gobbleWhitespace();
  const currNode = nodes[currPos];
  if (currNode == null || match.comment(currNode) || match.parbreak(currNode)) {
    return { argument, nodesRemoved: 0 };
  }
  switch (argSpec.type) {
    case "mandatory":
      if (acceptGroup) {
        let content = [currNode];
        if (match.group(currNode)) {
          content = currNode.content;
        }
        argument = arg(content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
    case "optional":
      if (acceptGroup && match.group(currNode)) {
        argument = arg(currNode.content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
      if (match.string(currNode, openMark)) {
        const [openMarkPos, closeMarkPos] = findBracePositions();
        if (openMarkPos != null && closeMarkPos != null) {
          argument = arg(nodes.slice(openMarkPos + 1, closeMarkPos), {
            openMark,
            closeMark
          });
          currPos = closeMarkPos + 1;
          break;
        }
      }
      break;
    case "optionalStar":
    case "optionalToken":
      if (match.string(
        currNode,
        argSpec.type === "optionalStar" ? "*" : argSpec.token
      )) {
        argument = arg([currNode], { openMark: "", closeMark: "" });
        currPos++;
        break;
      }
      break;
    case "until": {
      if (argSpec.stopTokens.length > 1) {
        console.warn(
          `"until" matches with multi-token stop conditions are not yet implemented`
        );
        break;
      }
      const rawToken = argSpec.stopTokens[0];
      const stopToken = rawToken === " " ? { type: "whitespace" } : { type: "string", content: argSpec.stopTokens[0] };
      let matchPos = scan(nodes, stopToken, {
        startIndex: startPos,
        allowSubstringMatches: true
      });
      if (matchPos != null && partialStringMatch(nodes[matchPos], stopToken)) {
        console.warn(
          `"until" arguments that stop at non-punctuation symbols is not yet implemented`
        );
        break;
      }
      if (matchPos == null) {
        break;
      }
      argument = arg(nodes.slice(startPos, matchPos), {
        openMark: "",
        closeMark: rawToken
      });
      currPos = matchPos;
      if (currPos < nodes.length) {
        currPos++;
      }
      break;
    }
    default:
      console.warn(
        `Don't know how to find an argument of argspec type "${argSpec.type}"`
      );
  }
  const nodesRemoved = argument ? currPos - startPos : 0;
  nodes.splice(startPos, nodesRemoved);
  return { argument, nodesRemoved };
}
function partialStringMatch(node, token) {
  return match.anyString(node) && match.anyString(token) && node.content.length > token.content.length;
}

// libs/gobble-arguments.ts
function gobbleArguments(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "function") {
    return argSpec(nodes, startPos);
  }
  if (typeof argSpec === "string") {
    argSpec = parseArgspec(argSpec);
  }
  const args = [];
  let nodesRemoved = 0;
  for (const spec of argSpec) {
    const { argument, nodesRemoved: removed } = gobbleSingleArgument(
      nodes,
      spec,
      startPos
    );
    if (argument) {
      args.push(argument);
      nodesRemoved += removed;
    } else {
      args.push(arg2([], { openMark: "", closeMark: "" }));
    }
  }
  return { args, nodesRemoved };
}

// libs/attach-arguments.ts
import { match as match2 } from "@unified-latex/unified-latex-util-match";
import { updateRenderInfo } from "@unified-latex/unified-latex-util-render-info";
import { visit } from "@unified-latex/unified-latex-util-visit";
function attachMacroArgsInArray(nodes, macros) {
  let currIndex;
  const isRelevantMacro = match2.createMacroMatcher(macros);
  function gobbleUntilMacro() {
    while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {
      currIndex--;
    }
  }
  currIndex = nodes.length - 1;
  while (currIndex >= 0) {
    gobbleUntilMacro();
    if (currIndex < 0) {
      return;
    }
    const macroIndex = currIndex;
    const macro = nodes[macroIndex];
    const macroName = macro.content;
    const macroInfo = macros[macroName];
    updateRenderInfo(macro, macroInfo.renderInfo);
    const signatureOrParser = macroInfo.argumentParser || macroInfo.signature;
    if (signatureOrParser == null) {
      currIndex--;
      continue;
    }
    if (macro.args != null) {
      currIndex = macroIndex - 1;
      continue;
    }
    currIndex++;
    const { args } = gobbleArguments(nodes, signatureOrParser, currIndex);
    macro.args = args;
    currIndex = macroIndex - 1;
  }
}
function attachMacroArgs(tree, macros) {
  visit(
    tree,
    (nodes) => {
      attachMacroArgsInArray(nodes, macros);
    },
    { includeArrays: true, test: Array.isArray }
  );
}

// libs/unified-latex-attach-macro-arguments.ts
import { visit as visit2 } from "@unified-latex/unified-latex-util-visit";
var unifiedLatexAttachMacroArguments = function unifiedLatexAttachMacroArguments2(options) {
  return (tree) => {
    const { macros = {} } = options || {};
    if (Object.keys(macros).length === 0) {
      console.warn(
        "Attempting to attach macro arguments but no macros are specified."
      );
    }
    visit2(
      tree,
      (nodes) => {
        attachMacroArgsInArray(nodes, macros);
      },
      { includeArrays: true, test: Array.isArray }
    );
  };
};

// libs/get-args-content.ts
function getArgsContent(node) {
  if (!Array.isArray(node.args)) {
    return [];
  }
  return node.args.map((arg3) => {
    if (arg3.openMark === "" && arg3.content.length === 0) {
      return null;
    }
    return arg3.content;
  });
}
function getNamedArgsContent(node, namedArgumentsFallback = []) {
  var _a;
  const names = ((_a = node._renderInfo) == null ? void 0 : _a.namedArguments) || namedArgumentsFallback;
  if (!Array.isArray(node.args) || !Array.isArray(names) || names.length === 0) {
    return {};
  }
  const ret = {};
  node.args.forEach((arg3, i) => {
    const name = names[i];
    if (name == null) {
      return;
    }
    let val = arg3.content;
    if (arg3.openMark === "" && arg3.content.length === 0) {
      val = null;
    }
    ret[name] = val;
  });
  return ret;
}
export {
  attachMacroArgs,
  attachMacroArgsInArray,
  getArgsContent,
  getNamedArgsContent,
  gobbleArguments,
  gobbleSingleArgument,
  unifiedLatexAttachMacroArguments
};
//# sourceMappingURL=index.js.map
