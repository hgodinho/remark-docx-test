"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var unified_latex_util_arguments_exports = {};
__export(unified_latex_util_arguments_exports, {
  attachMacroArgs: () => attachMacroArgs,
  attachMacroArgsInArray: () => attachMacroArgsInArray,
  getArgsContent: () => getArgsContent,
  getNamedArgsContent: () => getNamedArgsContent,
  gobbleArguments: () => gobbleArguments,
  gobbleSingleArgument: () => gobbleSingleArgument,
  unifiedLatexAttachMacroArguments: () => unifiedLatexAttachMacroArguments
});
module.exports = __toCommonJS(unified_latex_util_arguments_exports);

// libs/gobble-arguments.ts
var import_unified_latex_util_argspec = require("@unified-latex/unified-latex-util-argspec");
var import_unified_latex_builder2 = require("@unified-latex/unified-latex-builder");

// libs/gobble-single-argument.ts
var import_unified_latex_util_match = require("@unified-latex/unified-latex-util-match");
var import_unified_latex_util_scan = require("@unified-latex/unified-latex-util-scan");
var import_unified_latex_builder = require("@unified-latex/unified-latex-builder");
function gobbleSingleArgument(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "string" || !argSpec.type) {
    throw new Error(
      `argSpec must be an already-parsed argument specification, not "${JSON.stringify(
        argSpec
      )}"`
    );
  }
  let argument = null;
  let currPos = startPos;
  const gobbleWhitespace = argSpec.noLeadingWhitespace ? () => {
  } : () => {
    while (currPos < nodes.length) {
      if (!import_unified_latex_util_match.match.whitespace(nodes[currPos])) {
        break;
      }
      currPos++;
    }
  };
  const openMark = argSpec.openBrace || "";
  const closeMark = argSpec.closeBrace || "";
  const acceptGroup = (argSpec.type === "mandatory" || argSpec.type === "optional") && openMark === "{" && closeMark === "}";
  function findBracePositions() {
    let openMarkPos = null;
    if (openMark) {
      openMarkPos = nodes.findIndex(
        (node, i) => i >= currPos && import_unified_latex_util_match.match.string(node, openMark)
      );
      if (openMarkPos < currPos) {
        openMarkPos = null;
      }
    }
    let closeMarkPos = null;
    if (openMarkPos != null) {
      closeMarkPos = nodes.findIndex(
        (node, i) => i >= openMarkPos + 1 && import_unified_latex_util_match.match.string(node, closeMark)
      );
      if (closeMarkPos < openMarkPos + 1) {
        closeMarkPos = null;
      }
    }
    return [openMarkPos, closeMarkPos];
  }
  gobbleWhitespace();
  const currNode = nodes[currPos];
  if (currNode == null || import_unified_latex_util_match.match.comment(currNode) || import_unified_latex_util_match.match.parbreak(currNode)) {
    return { argument, nodesRemoved: 0 };
  }
  switch (argSpec.type) {
    case "mandatory":
      if (acceptGroup) {
        let content = [currNode];
        if (import_unified_latex_util_match.match.group(currNode)) {
          content = currNode.content;
        }
        argument = (0, import_unified_latex_builder.arg)(content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
    case "optional":
      if (acceptGroup && import_unified_latex_util_match.match.group(currNode)) {
        argument = (0, import_unified_latex_builder.arg)(currNode.content, {
          openMark,
          closeMark
        });
        currPos++;
        break;
      }
      if (import_unified_latex_util_match.match.string(currNode, openMark)) {
        const [openMarkPos, closeMarkPos] = findBracePositions();
        if (openMarkPos != null && closeMarkPos != null) {
          argument = (0, import_unified_latex_builder.arg)(nodes.slice(openMarkPos + 1, closeMarkPos), {
            openMark,
            closeMark
          });
          currPos = closeMarkPos + 1;
          break;
        }
      }
      break;
    case "optionalStar":
    case "optionalToken":
      if (import_unified_latex_util_match.match.string(
        currNode,
        argSpec.type === "optionalStar" ? "*" : argSpec.token
      )) {
        argument = (0, import_unified_latex_builder.arg)([currNode], { openMark: "", closeMark: "" });
        currPos++;
        break;
      }
      break;
    case "until": {
      if (argSpec.stopTokens.length > 1) {
        console.warn(
          `"until" matches with multi-token stop conditions are not yet implemented`
        );
        break;
      }
      const rawToken = argSpec.stopTokens[0];
      const stopToken = rawToken === " " ? { type: "whitespace" } : { type: "string", content: argSpec.stopTokens[0] };
      let matchPos = (0, import_unified_latex_util_scan.scan)(nodes, stopToken, {
        startIndex: startPos,
        allowSubstringMatches: true
      });
      if (matchPos != null && partialStringMatch(nodes[matchPos], stopToken)) {
        console.warn(
          `"until" arguments that stop at non-punctuation symbols is not yet implemented`
        );
        break;
      }
      if (matchPos == null) {
        break;
      }
      argument = (0, import_unified_latex_builder.arg)(nodes.slice(startPos, matchPos), {
        openMark: "",
        closeMark: rawToken
      });
      currPos = matchPos;
      if (currPos < nodes.length) {
        currPos++;
      }
      break;
    }
    default:
      console.warn(
        `Don't know how to find an argument of argspec type "${argSpec.type}"`
      );
  }
  const nodesRemoved = argument ? currPos - startPos : 0;
  nodes.splice(startPos, nodesRemoved);
  return { argument, nodesRemoved };
}
function partialStringMatch(node, token) {
  return import_unified_latex_util_match.match.anyString(node) && import_unified_latex_util_match.match.anyString(token) && node.content.length > token.content.length;
}

// libs/gobble-arguments.ts
function gobbleArguments(nodes, argSpec, startPos = 0) {
  if (typeof argSpec === "function") {
    return argSpec(nodes, startPos);
  }
  if (typeof argSpec === "string") {
    argSpec = (0, import_unified_latex_util_argspec.parse)(argSpec);
  }
  const args = [];
  let nodesRemoved = 0;
  for (const spec of argSpec) {
    const { argument, nodesRemoved: removed } = gobbleSingleArgument(
      nodes,
      spec,
      startPos
    );
    if (argument) {
      args.push(argument);
      nodesRemoved += removed;
    } else {
      args.push((0, import_unified_latex_builder2.arg)([], { openMark: "", closeMark: "" }));
    }
  }
  return { args, nodesRemoved };
}

// libs/attach-arguments.ts
var import_unified_latex_util_match2 = require("@unified-latex/unified-latex-util-match");
var import_unified_latex_util_render_info = require("@unified-latex/unified-latex-util-render-info");
var import_unified_latex_util_visit = require("@unified-latex/unified-latex-util-visit");
function attachMacroArgsInArray(nodes, macros) {
  let currIndex;
  const isRelevantMacro = import_unified_latex_util_match2.match.createMacroMatcher(macros);
  function gobbleUntilMacro() {
    while (currIndex >= 0 && !isRelevantMacro(nodes[currIndex])) {
      currIndex--;
    }
  }
  currIndex = nodes.length - 1;
  while (currIndex >= 0) {
    gobbleUntilMacro();
    if (currIndex < 0) {
      return;
    }
    const macroIndex = currIndex;
    const macro = nodes[macroIndex];
    const macroName = macro.content;
    const macroInfo = macros[macroName];
    (0, import_unified_latex_util_render_info.updateRenderInfo)(macro, macroInfo.renderInfo);
    const signatureOrParser = macroInfo.argumentParser || macroInfo.signature;
    if (signatureOrParser == null) {
      currIndex--;
      continue;
    }
    if (macro.args != null) {
      currIndex = macroIndex - 1;
      continue;
    }
    currIndex++;
    const { args } = gobbleArguments(nodes, signatureOrParser, currIndex);
    macro.args = args;
    currIndex = macroIndex - 1;
  }
}
function attachMacroArgs(tree, macros) {
  (0, import_unified_latex_util_visit.visit)(
    tree,
    (nodes) => {
      attachMacroArgsInArray(nodes, macros);
    },
    { includeArrays: true, test: Array.isArray }
  );
}

// libs/unified-latex-attach-macro-arguments.ts
var import_unified_latex_util_visit2 = require("@unified-latex/unified-latex-util-visit");
var unifiedLatexAttachMacroArguments = function unifiedLatexAttachMacroArguments2(options) {
  return (tree) => {
    const { macros = {} } = options || {};
    if (Object.keys(macros).length === 0) {
      console.warn(
        "Attempting to attach macro arguments but no macros are specified."
      );
    }
    (0, import_unified_latex_util_visit2.visit)(
      tree,
      (nodes) => {
        attachMacroArgsInArray(nodes, macros);
      },
      { includeArrays: true, test: Array.isArray }
    );
  };
};

// libs/get-args-content.ts
function getArgsContent(node) {
  if (!Array.isArray(node.args)) {
    return [];
  }
  return node.args.map((arg3) => {
    if (arg3.openMark === "" && arg3.content.length === 0) {
      return null;
    }
    return arg3.content;
  });
}
function getNamedArgsContent(node, namedArgumentsFallback = []) {
  var _a;
  const names = ((_a = node._renderInfo) == null ? void 0 : _a.namedArguments) || namedArgumentsFallback;
  if (!Array.isArray(node.args) || !Array.isArray(names) || names.length === 0) {
    return {};
  }
  const ret = {};
  node.args.forEach((arg3, i) => {
    const name = names[i];
    if (name == null) {
      return;
    }
    let val = arg3.content;
    if (arg3.openMark === "" && arg3.content.length === 0) {
      val = null;
    }
    ret[name] = val;
  });
  return ret;
}
//# sourceMappingURL=index.cjs.map
