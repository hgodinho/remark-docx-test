{
  "version": 3,
  "sources": ["../../../package/exam/index.ts", "../../../utils/enumerate.ts", "../../../package/exam/provides.ts"],
  "sourcesContent": ["export * from \"./provides\";\n", "import { arg } from \"@unified-latex/unified-latex-builder\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport {\n    lastSignificantNode,\n    lastSignificantNodeIndex,\n} from \"@unified-latex/unified-latex-util-replace\";\nimport { splitOnMacro } from \"@unified-latex/unified-latex-util-split\";\nimport { trim, trimEnd } from \"@unified-latex/unified-latex-util-trim\";\n\n/**\n * Clean up any whitespace issues in an enumerate environment. In particular,\n *      * Remove any leading or ending whitespace\n *      * Ensure there is a par between occurrences of `\\item`\n *      * Ensure there is whitespace after each occurrence of `\\item` provided there is content there\n * `itemName` can be used to set what the \"item\" macro is called.\n *\n * This function attaches content following a `\\item` to the `\\item` macro with\n * `openMark` and `closeMark` set to empty. This allows hanging-indents to be rendered.\n */\nexport function cleanEnumerateBody(\n    ast: Ast.Node[],\n    itemName = \"item\"\n): Ast.Node[] {\n    let { segments, macros } = splitOnMacro(ast, itemName);\n    // Trim the content of each block, but make sure there is a space\n    // between each macro and the content. Since the first segment of content\n    // appears *before* any macro, don't add a space there.\n    for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (i === 0) {\n            // The very first segment might be comment with leading whitespace. We don't want to trim that off\n            trimEnd(segment);\n        } else {\n            trim(segment);\n        }\n        // The very first segment comes before any `\\item` macros. It is either\n        // blank or contains comments (or is invalid LaTeX). We don't insert a space\n        // in this case.\n        if (segment.length > 0 && i > 0) {\n            segment.unshift({ type: \"whitespace\" });\n        }\n    }\n\n    let insertParbreakBefore: WeakSet<Ast.Node> = new WeakSet();\n\n    // We want a trailing indent for the `\\item` nodes. We will\n    // do this with a trick: we will add an argument to the index node\n    // with openMark=\" \" and closeMark=\"\"\n    let body: Ast.Node[] = macros.flatMap((node, i) => {\n        const segment = segments[i + 1];\n        const trailingComments = popTrailingComments(segment);\n        node.args = node.args || [];\n        node.args.push(arg(segment, { openMark: \"\", closeMark: \"\" }));\n        updateRenderInfo(node, { inParMode: true });\n\n        // The stream contains a mix of `\\item` macros and comments/parbreaks. We only\n        // want to insert parbreaks before `\\item` macros, so we record these for later.\n        if (i > 0 || segments[0]?.length > 0) {\n            insertParbreakBefore.add(node);\n        }\n\n        return [node, ...trailingComments];\n    });\n\n    // We want a parbreak between each `\\item` block and the preceding content.\n    // We've already logged the `\\item` macros in `insertParbreakBefore`.\n    body = body.flatMap((node) =>\n        insertParbreakBefore.has(node) ? [{ type: \"parbreak\" }, node] : node\n    );\n\n    body.unshift(...segments[0]);\n\n    // We have inserted parbreaks so some comments need to be told that there is a suffix parbreak\n    for (let i = 0; i < body.length - 1; i++) {\n        const node = body[i];\n        const nextNode = body[i + 1];\n        if (!match.parbreak(nextNode)) {\n            continue;\n        }\n        if (match.comment(node)) {\n            node.suffixParbreak = true;\n        }\n        // The heuristic for detecting an `item`-like node is that its last argument has no close mark.\n        // Regardless of what it is, if there is no close mark, when rendered we don't want two newlines to\n        // appear.\n        if (\n            match.macro(node) &&\n            node.args &&\n            node.args[node.args.length - 1].closeMark === \"\"\n        ) {\n            const args = node.args[node.args.length - 1].content;\n            const lastArg = args[args.length - 1];\n            if (match.comment(lastArg)) {\n                lastArg.suffixParbreak = true;\n            }\n        }\n    }\n\n    return body;\n}\n\n/**\n * Removes and returns any number of trailing comments/parbreaks from `nodes`.\n */\nfunction popTrailingComments(nodes: Ast.Node[]): Ast.Node[] {\n    let lastNodeIndex = lastSignificantNodeIndex(nodes, true);\n    if (\n        lastNodeIndex === nodes.length - 1 ||\n        (lastNodeIndex == null && nodes.length === 0)\n    ) {\n        return [];\n    }\n\n    // If `nodes` has a non-zero length and we didn't find a significant node, everything is comments!\n    if (lastNodeIndex == null) {\n        lastNodeIndex = -1;\n    }\n    return nodes.splice(lastNodeIndex + 1);\n}\n", "import { MacroInfoRecord, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { cleanEnumerateBody } from \"../../utils/enumerate\";\n\nexport const macros: MacroInfoRecord = {\n    answerline: { signature: \"o\" },\n    fillin: { signature: \"o o\" },\n    fullwidth: { signature: \"m\" },\n    fillwidthlines: { signature: \"m\" },\n    fillwidthdottedlines: { signature: \"m\" },\n    fillwidthgrid: { signature: \"m\" },\n    makeemptybox: { signature: \"m\" },\n    CorrectChoiceEmphasis: {\n        signature: \"m\",\n        renderInfo: { breakAround: true },\n    },\n    SolutionEmphasis: { signature: \"m\", renderInfo: { breakAround: true } },\n    uplevel: { signature: \"m\", renderInfo: { breakAround: true } },\n    checkboxchar: { signature: \"m\", renderInfo: { breakAround: true } },\n    checkedchar: { signature: \"m\", renderInfo: { breakAround: true } },\n    pointname: { signature: \"m\", renderInfo: { breakAround: true } },\n    marginpointname: { signature: \"m\", renderInfo: { breakAround: true } },\n    extrawidth: { signature: \"m\", renderInfo: { breakAround: true } },\n    pointformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    bonuspointformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    totalformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    qformat: { signature: \"m\", renderInfo: { breakAround: true } },\n    titledquestion: { signature: \"m o\", renderInfo: { breakAround: true } },\n    pointpoints: { signature: \"m m\", renderInfo: { breakAround: true } },\n    bonuspointpoints: { signature: \"m m\", renderInfo: { breakAround: true } },\n};\n\nexport const environments: EnvInfoRecord = {\n    choices: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    checkboxes: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    oneparchoices: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    oneparcheckboxes: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"choice\"),\n    },\n    parts: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"part\"),\n    },\n    subparts: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"subpart\"),\n    },\n    subsubparts: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"subsubpart\"),\n    },\n    questions: {\n        signature: \"o\",\n        processContent: (nodes) => cleanEnumerateBody(nodes, \"question\"),\n    },\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,mCAAoB;AAEpB,sCAAsB;AAEtB,4CAAiC;AACjC,wCAGO;AACP,sCAA6B;AAC7B,qCAA8B;AAYvB,SAAS,mBACZ,KACA,WAAW,QACD;AACV,MAAI,EAAE,UAAU,QAAAA,QAAO,QAAI,8CAAa,KAAK,QAAQ;AAIrD,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACtC,UAAM,UAAU,SAAS,CAAC;AAC1B,QAAI,MAAM,GAAG;AAET,kDAAQ,OAAO;AAAA,IACnB,OAAO;AACH,+CAAK,OAAO;AAAA,IAChB;AAIA,QAAI,QAAQ,SAAS,KAAK,IAAI,GAAG;AAC7B,cAAQ,QAAQ,EAAE,MAAM,aAAa,CAAC;AAAA,IAC1C;AAAA,EACJ;AAEA,MAAI,uBAA0C,oBAAI,QAAQ;AAK1D,MAAI,OAAmBA,QAAO,QAAQ,CAAC,MAAM,MAAM;AAnDvD;AAoDQ,UAAM,UAAU,SAAS,IAAI,CAAC;AAC9B,UAAM,mBAAmB,oBAAoB,OAAO;AACpD,SAAK,OAAO,KAAK,QAAQ,CAAC;AAC1B,SAAK,KAAK,SAAK,kCAAI,SAAS,EAAE,UAAU,IAAI,WAAW,GAAG,CAAC,CAAC;AAC5D,gEAAiB,MAAM,EAAE,WAAW,KAAK,CAAC;AAI1C,QAAI,IAAI,OAAK,cAAS,CAAC,MAAV,mBAAa,UAAS,GAAG;AAClC,2BAAqB,IAAI,IAAI;AAAA,IACjC;AAEA,WAAO,CAAC,MAAM,GAAG,gBAAgB;AAAA,EACrC,CAAC;AAID,SAAO,KAAK;AAAA,IAAQ,CAAC,SACjB,qBAAqB,IAAI,IAAI,IAAI,CAAC,EAAE,MAAM,WAAW,GAAG,IAAI,IAAI;AAAA,EACpE;AAEA,OAAK,QAAQ,GAAG,SAAS,CAAC,CAAC;AAG3B,WAAS,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AACtC,UAAM,OAAO,KAAK,CAAC;AACnB,UAAM,WAAW,KAAK,IAAI,CAAC;AAC3B,QAAI,CAAC,sCAAM,SAAS,QAAQ,GAAG;AAC3B;AAAA,IACJ;AACA,QAAI,sCAAM,QAAQ,IAAI,GAAG;AACrB,WAAK,iBAAiB;AAAA,IAC1B;AAIA,QACI,sCAAM,MAAM,IAAI,KAChB,KAAK,QACL,KAAK,KAAK,KAAK,KAAK,SAAS,CAAC,EAAE,cAAc,IAChD;AACE,YAAM,OAAO,KAAK,KAAK,KAAK,KAAK,SAAS,CAAC,EAAE;AAC7C,YAAM,UAAU,KAAK,KAAK,SAAS,CAAC;AACpC,UAAI,sCAAM,QAAQ,OAAO,GAAG;AACxB,gBAAQ,iBAAiB;AAAA,MAC7B;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO;AACX;AAKA,SAAS,oBAAoB,OAA+B;AACxD,MAAI,oBAAgB,4DAAyB,OAAO,IAAI;AACxD,MACI,kBAAkB,MAAM,SAAS,KAChC,iBAAiB,QAAQ,MAAM,WAAW,GAC7C;AACE,WAAO,CAAC;AAAA,EACZ;AAGA,MAAI,iBAAiB,MAAM;AACvB,oBAAgB;AAAA,EACpB;AACA,SAAO,MAAM,OAAO,gBAAgB,CAAC;AACzC;;;ACtHO,IAAM,SAA0B;AAAA,EACnC,YAAY,EAAE,WAAW,IAAI;AAAA,EAC7B,QAAQ,EAAE,WAAW,MAAM;AAAA,EAC3B,WAAW,EAAE,WAAW,IAAI;AAAA,EAC5B,gBAAgB,EAAE,WAAW,IAAI;AAAA,EACjC,sBAAsB,EAAE,WAAW,IAAI;AAAA,EACvC,eAAe,EAAE,WAAW,IAAI;AAAA,EAChC,cAAc,EAAE,WAAW,IAAI;AAAA,EAC/B,uBAAuB;AAAA,IACnB,WAAW;AAAA,IACX,YAAY,EAAE,aAAa,KAAK;AAAA,EACpC;AAAA,EACA,kBAAkB,EAAE,WAAW,KAAK,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EACtE,SAAS,EAAE,WAAW,KAAK,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EAC7D,cAAc,EAAE,WAAW,KAAK,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EAClE,aAAa,EAAE,WAAW,KAAK,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EACjE,WAAW,EAAE,WAAW,KAAK,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EAC/D,iBAAiB,EAAE,WAAW,KAAK,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EACrE,YAAY,EAAE,WAAW,KAAK,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EAChE,aAAa,EAAE,WAAW,KAAK,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EACjE,kBAAkB,EAAE,WAAW,KAAK,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EACtE,aAAa,EAAE,WAAW,KAAK,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EACjE,SAAS,EAAE,WAAW,KAAK,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EAC7D,gBAAgB,EAAE,WAAW,OAAO,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EACtE,aAAa,EAAE,WAAW,OAAO,YAAY,EAAE,aAAa,KAAK,EAAE;AAAA,EACnE,kBAAkB,EAAE,WAAW,OAAO,YAAY,EAAE,aAAa,KAAK,EAAE;AAC5E;AAEO,IAAM,eAA8B;AAAA,EACvC,SAAS;AAAA,IACL,WAAW;AAAA,IACX,gBAAgB,CAAC,UAAU,mBAAmB,OAAO,QAAQ;AAAA,EACjE;AAAA,EACA,YAAY;AAAA,IACR,WAAW;AAAA,IACX,gBAAgB,CAAC,UAAU,mBAAmB,OAAO,QAAQ;AAAA,EACjE;AAAA,EACA,eAAe;AAAA,IACX,WAAW;AAAA,IACX,gBAAgB,CAAC,UAAU,mBAAmB,OAAO,QAAQ;AAAA,EACjE;AAAA,EACA,kBAAkB;AAAA,IACd,WAAW;AAAA,IACX,gBAAgB,CAAC,UAAU,mBAAmB,OAAO,QAAQ;AAAA,EACjE;AAAA,EACA,OAAO;AAAA,IACH,WAAW;AAAA,IACX,gBAAgB,CAAC,UAAU,mBAAmB,OAAO,MAAM;AAAA,EAC/D;AAAA,EACA,UAAU;AAAA,IACN,WAAW;AAAA,IACX,gBAAgB,CAAC,UAAU,mBAAmB,OAAO,SAAS;AAAA,EAClE;AAAA,EACA,aAAa;AAAA,IACT,WAAW;AAAA,IACX,gBAAgB,CAAC,UAAU,mBAAmB,OAAO,YAAY;AAAA,EACrE;AAAA,EACA,WAAW;AAAA,IACP,WAAW;AAAA,IACX,gBAAgB,CAAC,UAAU,mBAAmB,OAAO,UAAU;AAAA,EACnE;AACJ;",
  "names": ["macros"]
}
