{
  "version": 3,
  "sources": ["../libs/process-environment.ts", "../libs/unified-latex-process-environment.ts"],
  "sourcesContent": ["import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfo, EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { updateRenderInfo } from \"@unified-latex/unified-latex-util-render-info\";\nimport { gobbleArguments } from \"@unified-latex/unified-latex-util-arguments\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\n/**\n * Performs any needed processing on the environment (as specified by `envInfo`)\n * including attaching arguments and possibly manipulating the environment's body.\n */\nexport function processEnvironment(envNode: Ast.Environment, envInfo: EnvInfo) {\n    if (envInfo.signature && envNode.args == null) {\n        const { args } = gobbleArguments(envNode.content, envInfo.signature);\n        envNode.args = args;\n    }\n\n    updateRenderInfo(envNode, envInfo.renderInfo);\n    if (typeof envInfo.processContent === \"function\") {\n        envNode.content = envInfo.processContent(envNode.content);\n    }\n}\n\n/**\n * Recursively search for and process the specified environments. Arguments are\n * consumed according to the `signature` specified. The body is processed\n * with the specified `processContent` function (if given). Any specified `renderInfo`\n * is attached to the environment node.\n */\nexport function processEnvironments(\n    tree: Ast.Ast,\n    environments: EnvInfoRecord\n) {\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n\n    visit(\n        tree,\n        {\n            leave: (node) => {\n                const envName = printRaw(node.env);\n                const envInfo = environments[envName];\n                if (!envInfo) {\n                    throw new Error(\n                        `Could not find environment info for environment \"${envName}\"`\n                    );\n                }\n                processEnvironment(node, envInfo);\n            },\n        },\n        { test: isRelevantEnvironment }\n    );\n}\n", "import * as Ast from \"@unified-latex/unified-latex-types\";\nimport { EnvInfoRecord } from \"@unified-latex/unified-latex-types\";\nimport { Plugin } from \"unified\";\nimport { visit } from \"@unified-latex/unified-latex-util-visit\";\nimport { match } from \"@unified-latex/unified-latex-util-match\";\nimport { processEnvironment } from \"./process-environment\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\ntype PluginOptions = { environments: EnvInfoRecord } | undefined;\n\n/**\n * Unified plugin to process environment content and attach arguments.\n *\n * @param environments An object whose keys are environment names and values contains information about the environment and its argument signature.\n */\nexport const unifiedLatexProcessEnvironments: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    Ast.Root\n> = function unifiedLatexAttachMacroArguments(options) {\n    const { environments = {} } = options || {};\n    const isRelevantEnvironment = match.createEnvironmentMatcher(environments);\n\n    return (tree) => {\n        if (Object.keys(environments).length === 0) {\n            console.warn(\n                \"Attempting to attach macro arguments but no macros are specified.\"\n            );\n        }\n\n        visit(\n            tree,\n            {\n                leave: (node) => {\n                    const envName = printRaw(node.env);\n                    const envInfo = environments[envName];\n                    if (!envInfo) {\n                        throw new Error(\n                            `Could not find environment info for environment \"${envName}\"`\n                        );\n                    }\n                    processEnvironment(node, envInfo);\n                },\n            },\n            { test: isRelevantEnvironment }\n        );\n    };\n};\n"],
  "mappings": ";AAEA,SAAS,wBAAwB;AACjC,SAAS,uBAAuB;AAChC,SAAS,aAAa;AACtB,SAAS,aAAa;AACtB,SAAS,gBAAgB;AAMlB,SAAS,mBAAmB,SAA0B,SAAkB;AAC3E,MAAI,QAAQ,aAAa,QAAQ,QAAQ,MAAM;AAC3C,UAAM,EAAE,KAAK,IAAI,gBAAgB,QAAQ,SAAS,QAAQ,SAAS;AACnE,YAAQ,OAAO;AAAA,EACnB;AAEA,mBAAiB,SAAS,QAAQ,UAAU;AAC5C,MAAI,OAAO,QAAQ,mBAAmB,YAAY;AAC9C,YAAQ,UAAU,QAAQ,eAAe,QAAQ,OAAO;AAAA,EAC5D;AACJ;AAQO,SAAS,oBACZ,MACA,cACF;AACE,QAAM,wBAAwB,MAAM,yBAAyB,YAAY;AAEzE;AAAA,IACI;AAAA,IACA;AAAA,MACI,OAAO,CAAC,SAAS;AACb,cAAM,UAAU,SAAS,KAAK,GAAG;AACjC,cAAM,UAAU,aAAa,OAAO;AACpC,YAAI,CAAC,SAAS;AACV,gBAAM,IAAI;AAAA,YACN,oDAAoD;AAAA,UACxD;AAAA,QACJ;AACA,2BAAmB,MAAM,OAAO;AAAA,MACpC;AAAA,IACJ;AAAA,IACA,EAAE,MAAM,sBAAsB;AAAA,EAClC;AACJ;;;ACjDA,SAAS,SAAAA,cAAa;AACtB,SAAS,SAAAC,cAAa;AAEtB,SAAS,YAAAC,iBAAgB;AASlB,IAAM,kCAIT,SAAS,iCAAiC,SAAS;AACnD,QAAM,EAAE,eAAe,CAAC,EAAE,IAAI,WAAW,CAAC;AAC1C,QAAM,wBAAwBC,OAAM,yBAAyB,YAAY;AAEzE,SAAO,CAAC,SAAS;AACb,QAAI,OAAO,KAAK,YAAY,EAAE,WAAW,GAAG;AACxC,cAAQ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAEA,IAAAC;AAAA,MACI;AAAA,MACA;AAAA,QACI,OAAO,CAAC,SAAS;AACb,gBAAM,UAAUF,UAAS,KAAK,GAAG;AACjC,gBAAM,UAAU,aAAa,OAAO;AACpC,cAAI,CAAC,SAAS;AACV,kBAAM,IAAI;AAAA,cACN,oDAAoD;AAAA,YACxD;AAAA,UACJ;AACA,6BAAmB,MAAM,OAAO;AAAA,QACpC;AAAA,MACJ;AAAA,MACA,EAAE,MAAM,sBAAsB;AAAA,IAClC;AAAA,EACJ;AACJ;",
  "names": ["visit", "match", "printRaw", "match", "visit"]
}
